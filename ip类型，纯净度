脚本一（你的“IP 段→扫 8636→探测 /panel→匹配 3X-UI”版本）
import socket, ipaddress, sys, threading, time, os, requests, re
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Iterator, Dict, Optional, Tuple, List
from tqdm import tqdm
import warnings
warnings.filterwarnings("ignore", category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

# ===== 原有可配置常量 =====
PORT_SCAN_TIMEOUT = 3.0
MAX_WORKERS_SCAN = min(500, os.cpu_count() * 50)
BATCH_SIZE_SCAN = 5000
PORT = 8636
RESULT_OPEN = "open_8636.txt"
PANEL_PATH = "/panel"
WEB_TIMEOUT = 10.0
MAX_WORKERS_WEB = min(150, os.cpu_count() * 20)
KEYWORD = "3X-UI"
RESULT_FINAL = "3xui_panel_ips.txt"
# =========================

lock = threading.Lock()
open_cnt = 0
found_3xui = 0
pbar: tqdm = None

session = requests.Session()
session.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"

# ---------- 新增：ping0.cc 解析与缓存 ----------
_ping0_cache: Dict[str, Tuple[Optional[bool], Optional[str]]] = {}
_ping0_cache_lock = threading.Lock()

def _normalize_ip_type(text: str) -> Optional[str]:
    # 优先识别：家宽 / 原生 / 广播ip（包含“广播/IDC/数据中心/云服务器”都归到广播ip）
    if any(k in text for k in ("家宽",)):
        return "家宽"
    if any(k in text for k in ("原生", "原生IP", "Native")):
        return "原生"
    if any(k in text for k in ("广播ip", "广播 IP", "广播", "IDC", "数据中心", "云服务器", "BGP", "机房")):
        return "广播ip"
    return None

def _parse_risk(text: str) -> Optional[bool]:
    # 识别“风控：是/否/开启/关闭/存在/无”等
    if re.search(r"风控\s*[:：]?\s*(是|开启|存在|已开启)", text):
        return True
    if re.search(r"风控\s*[:：]?\s*(否|关闭|无|未发现)", text):
        return False
    return None

def ping0_check(ip: str) -> Tuple[Optional[bool], Optional[str]]:
    """访问 ping0.cc 的 IP 页面并尽量解析 风控(True/False/None) 与 IP 类型('家宽'/'原生'/'广播ip'/None)"""
    with _ping0_cache_lock:
        if ip in _ping0_cache:
            return _ping0_cache[ip]

    url = f"https://ping0.cc/ip/{ip}"
    risk: Optional[bool] = None
    ip_type: Optional[str] = None
    try:
        r = requests.get(url, timeout=8)
        txt = r.text
        risk = _parse_risk(txt)
        ip_type = _normalize_ip_type(txt)
    except Exception:
        risk, ip_type = None, None

    with _ping0_cache_lock:
        _ping0_cache[ip] = (risk, ip_type)
    return risk, ip_type

def label_str(risk: Optional[bool], ip_type: Optional[str]) -> str:
    risk_s = "是" if risk is True else ("否" if risk is False else "未知")
    type_s = ip_type or "未知"
    return f"TYPE={type_s}\t风控={risk_s}"
# ------------------------------------------------

def check_port(ip: str, port: int = PORT) -> bool:
    try:
        s = socket.create_connection((ip, port), timeout=PORT_SCAN_TIMEOUT)
        s.close()
        return True
    except:
        return False

def check_panel(ip: str) -> bool:
    global found_3xui, pbar
    url = f"http://{ip}:{PORT}{PANEL_PATH}"
    try:
        r = session.get(url, timeout=WEB_TIMEOUT, verify=False)
        pbar.update(1)
        if r.status_code == 200 and KEYWORD.lower() in r.text.lower():
            # 新增：对该 IP 做风控与类型标注
            risk, ip_type = ping0_check(ip)
            line = f"{ip}:{PORT}{PANEL_PATH}\t{label_str(risk, ip_type)}\n"
            with lock:
                found_3xui += 1
                with open(RESULT_FINAL, "a", encoding="utf-8") as f:
                    f.write(line)
            pbar.write(f"[3X-UI PANEL] {ip}:{PORT}{PANEL_PATH} → {url}")
            return True
    except:
        pass
    pbar.update(1)
    return False

def ip_range_generator(start_ip: str, end_ip: str) -> Iterator[str]:
    start = int(ipaddress.IPv4Address(start_ip))
    end = int(ipaddress.IPv4Address(end_ip))
    for i in range(start, end + 1):
        yield str(ipaddress.IPv4Address(i))

def chunked(iterable, size):
    it = iter(iterable)
    while True:
        chunk = []
        try:
            for _ in range(size):
                chunk.append(next(it))
            yield chunk
        except StopIteration:
            if chunk:
                yield chunk
            break

def main():
    global pbar, open_cnt, found_3xui
    print("OTC TG群@soqunla + 3X-UI 一体化探测器（含风控与IP类型标注）")
    print("最终输出: 仅含 3X-UI 的 IP:端口，并附 TYPE/风控 标注\n")

    rng = input("IP范围 (如 0.0.0.0-255.255.255.255): ").strip()
    if not rng or "-" not in rng:
        print("[!] 请输入正确范围，如 1.1.1.1-2.2.2.2")
        return
    start_ip, end_ip = rng.split("-", 1)
    total_ips = int(ipaddress.IPv4Address(end_ip)) - int(ipaddress.IPv4Address(start_ip)) + 1

    open(RESULT_OPEN, "w", encoding="utf-8").write(f"# {PORT} 端口开放的 IP 列表（含 TYPE/风控）\n")
    open(RESULT_FINAL, "w", encoding="utf-8").write(
        f"# 3X-UI 面板 ({PANEL_PATH}) 页面包含 '{KEYWORD}'（含 TYPE/风控）\n"
        f"# 格式: IP:端口[路径]\\tTYPE=xx\\t风控=是/否/未知\n"
        f"# 生成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n"
    )

    print(f"\n[步骤1] 起飞 → 扫描 {total_ips:,} 个 IP 的 {PORT} 端口\n")
    pbar = tqdm(total=total_ips, desc="扫描端口", unit="ip", ncols=90,
                bar_format="{l_bar}{bar}| {n_fmt}/{total} [{elapsed}<{remaining}, {rate_fmt}{postfix}]")

    open_ips = []
    with ThreadPoolExecutor(MAX_WORKERS_SCAN) as exe:
        batch_count = 0
        for ip_batch in chunked(ip_range_generator(start_ip, end_ip), BATCH_SIZE_SCAN):
            batch_count += 1
            futures = [exe.submit(check_port, ip) for ip in ip_batch]
            for ip, future in zip(ip_batch, as_completed(futures)):
                ok = False
                try:
                    ok = future.result()
                except:
                    ok = False

                if ok:
                    with lock:
                        open_cnt += 1
                        open_ips.append(ip)
                        # 新增：开放端口即做风控与类型标注（缓存避免重复）
                        risk, ip_type = ping0_check(ip)
                        with open(RESULT_OPEN, "a", encoding="utf-8") as f:
                            f.write(f"{ip}:{PORT}\t{label_str(risk, ip_type)}\n")
                pbar.update(1)
            print(f"[i] 第 {batch_count} 批完成，累计 {min(batch_count * BATCH_SIZE_SCAN, total_ips)} 个 IP")

    pbar.close()
    print(f"\n[步骤1 完成] 共发现 {open_cnt} 个 {PORT} 端口开放 → {RESULT_OPEN}\n")

    if open_cnt == 0:
        print("未发现开放端口，程序结束。")
        return
    print(f"[步骤2] 起飞 → 探测 {open_cnt:,} 个 IP 的 {PANEL_PATH} 页面是否含 '{KEYWORD}'\n")

    pbar = tqdm(total=open_cnt, desc="探测面板", unit="ip", ncols=90,
                bar_format="{l_bar}{bar}| {n_fmt}/{total} [{elapsed}<{remaining}, {rate_fmt}{postfix}]")

    with ThreadPoolExecutor(MAX_WORKERS_WEB) as exe:
        futures = [exe.submit(check_panel, ip) for ip in open_ips]
        for f in as_completed(futures):
            try:
                f.result()
            except:
                pass

    pbar.close()
    print(f"\n\n大功告成！共发现 {found_3xui} 个 3X-UI 面板")
    print(f"   开放端口列表 → {RESULT_OPEN}")
    print(f"   3X-UI 面板列表 → {RESULT_FINAL}")

    if found_3xui > 0:
        print(f"   示例：")
        with open(RESULT_FINAL, "r", encoding="utf-8") as f:
            for i, line in enumerate(f):
                if i >= 5: break
                if not line.startswith("#"):
                    print(f"     {line.strip()}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n已手动停止，当前进度：{open_cnt} 个开放，{found_3xui} 个 3X-UI")
        sys.exit(0)

脚本二（“固定一个 IP → 输入端口区间”版本）
import socket, sys, threading, time, os, requests, re
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Iterator, Optional, Tuple, Dict
from tqdm import tqdm

# ================== 可配置常量 ==================
TARGET_IP = "127.0.0.1"        # 固定要扫描的 IP（按需改）
PORT_SCAN_TIMEOUT = 2.0        # 端口探测超时（秒）
MAX_WORKERS_SCAN = min(500, (os.cpu_count() or 1) * 50)
BATCH_SIZE_SCAN = 2000         # 每批任务数
RESULT_OPEN = "open_ports.txt" # 输出文件
# ==============================================

lock = threading.Lock()
open_cnt = 0
pbar: tqdm = None

# 新增：ping0.cc 检测所需
_ping0_cache: Dict[str, Tuple[Optional[bool], Optional[str]]] = {}
_ping0_cache_lock = threading.Lock()

def _normalize_ip_type(text: str) -> Optional[str]:
    if any(k in text for k in ("家宽",)):
        return "家宽"
    if any(k in text for k in ("原生", "原生IP", "Native")):
        return "原生"
    if any(k in text for k in ("广播ip", "广播 IP", "广播", "IDC", "数据中心", "云服务器", "BGP", "机房")):
        return "广播ip"
    return None

def _parse_risk(text: str) -> Optional[bool]:
    if re.search(r"风控\s*[:：]?\s*(是|开启|存在|已开启)", text):
        return True
    if re.search(r"风控\s*[:：]?\s*(否|关闭|无|未发现)", text):
        return False
    return None

def ping0_check(ip: str) -> Tuple[Optional[bool], Optional[str]]:
    with _ping0_cache_lock:
        if ip in _ping0_cache:
            return _ping0_cache[ip]
    url = f"https://ping0.cc/ip/{ip}"
    risk: Optional[bool] = None
    ip_type: Optional[str] = None
    try:
        r = requests.get(url, timeout=8)
        txt = r.text
        risk = _parse_risk(txt)
        ip_type = _normalize_ip_type(txt)
    except Exception:
        risk, ip_type = None, None
    with _ping0_cache_lock:
        _ping0_cache[ip] = (risk, ip_type)
    return risk, ip_type

def label_str(risk: Optional[bool], ip_type: Optional[str]) -> str:
    risk_s = "是" if risk is True else ("否" if risk is False else "未知")
    type_s = ip_type or "未知"
    return f"TYPE={type_s}\t风控={risk_s}"

def check_port(ip: str, port: int) -> bool:
    try:
        s = socket.create_connection((ip, port), timeout=PORT_SCAN_TIMEOUT)
        s.close()
        return True
    except:
        return False

def port_range_generator(start_port: int, end_port: int):
    for p in range(start_port, end_port + 1):
        yield p

def chunked(iterable, size):
    it = iter(iterable)
    while True:
        chunk = []
        try:
            for _ in range(size):
                chunk.append(next(it))
            yield chunk
        except StopIteration:
            if chunk:
                yield chunk
            break

def main():
    global pbar, open_cnt
    print("固定 IP 端口扫描器（含风控与IP类型标注）")
    print(f"目标 IP：{TARGET_IP}\n")

    rng = input("端口区间 (如 1-65535): ").strip()
    if not rng or "-" not in rng:
        print("[!] 请输入正确区间，如 1-1024")
        return
    try:
        start_port, end_port = [int(x) for x in rng.split("-", 1)]
        if not (0 < start_port <= 65535 and 0 < end_port <= 65535 and start_port <= end_port):
            raise ValueError
    except:
        print("[!] 端口区间不合法，必须是 1-65535 范围内的整数，且前者 <= 后者")
        return

    total_ports = end_port - start_port + 1

    with open(RESULT_OPEN, "w", encoding="utf-8") as f:
        f.write(f"# {TARGET_IP} 开放端口列表（含 TYPE/风控）\n")
        f.write(f"# 扫描范围: {start_port}-{end_port}\n")
        f.write(f"# 生成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n")

    # 新增：在扫描前先获取并缓存一次该 IP 的风控与类型（也可放在每次写入时懒加载）
    risk, ip_type = ping0_check(TARGET_IP)

    print(f"\n[步骤] 起飞 → 扫描 {TARGET_IP} 的端口 {start_port}-{end_port}\n")
    pbar = tqdm(total=total_ports, desc="扫描端口", unit="port", ncols=90,
                bar_format="{l_bar}{bar}| {n_fmt}/{total} [{elapsed}<{remaining}, {rate_fmt}{postfix}]")

    open_ports = []
    with ThreadPoolExecutor(MAX_WORKERS_SCAN) as exe:
        batch_idx = 0
        for port_batch in chunked(port_range_generator(start_port, end_port), BATCH_SIZE_SCAN):
            batch_idx += 1
            future_map = {exe.submit(check_port, TARGET_IP, p): p for p in port_batch}
            for fut in as_completed(future_map):
                port = future_map[fut]
                try:
                    ok = fut.result()
                except:
                    ok = False
                if ok:
                    with lock:
                        open_cnt += 1
                        open_ports.append(port)
                        with open(RESULT_OPEN, "a", encoding="utf-8") as f:
                            f.write(f"{port}\t{label_str(risk, ip_type)}\n")
                pbar.update(1)
            print(f"[i] 第 {batch_idx} 批完成，累计 {min(batch_idx * BATCH_SIZE_SCAN, total_ports)} 个端口")

    pbar.close()
    print(f"\n[完成] {TARGET_IP} 在 {total_ports} 个端口中共开放 {open_cnt} 个 → {RESULT_OPEN}\n")
    if open_ports:
        sample = ", ".join(str(p) for p in open_ports[:20])
        print(f"示例（前 20 个）：{sample}")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n已手动停止，当前进度：{open_cnt} 个开放端口")
        sys.exit(0)
